{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"essex-toolkit","text":"<p>Provides a set of useful tools, utilities, reusable components, and React hooks built to support our team built library ecosystem. Packages are designed to capture common components and utilities common among projects. See individual package README for specific information.</p>"},{"location":"#python","title":"Python","text":""},{"location":"#essex-config","title":"essex-config","text":"<p>A configuration library that allows for easy configuration of Python applications using environment variables, files, and Azure Key Vault.</p>"},{"location":"#fnllm","title":"fnllm","text":"<p>An LLM wrapper library that provides rate limiting, retry logic, caching, JSON model parsing, and more.</p>"},{"location":"#reactivedataflow","title":"reactivedataflow","text":"<p>A library for creating reactive data flows in Python.</p>"},{"location":"#javascript","title":"JavaScript","text":""},{"location":"#essex-toolkit-storybook","title":"essex-toolkit Storybook","text":"<p>A Storybook for the essex-toolkit packages.</p>"},{"location":"#tests","title":"Tests","text":"<p>Limited tests are provided within the packages and most components/functions are experimental</p>"},{"location":"#license","title":"License","text":"<p>Licensed under the MIT License.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.</p> <p>When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p> <p>This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"essex-config/","title":"Getting Started","text":"<p>essex-config is a Python library for creating configuration objects that read from various sources, including files, environment variables, and Azure Key Vault.</p> <pre><code>pip install essex-config\n</code></pre>"},{"location":"essex-config/#basic-usage","title":"Basic Usage","text":"<p>Create a configuration object for connecting to a customer database:</p> <pre><code>from pydantic import BaseModel, Field\nfrom essex_config import load_config\n\nclass CustomerDatabase(BaseModel):\n    \"\"\"Configuration for connecting to the Customer Database\"\"\"\n    host: str = Field(default=\"127.0.0.1\", description=\"DB connection host\")\n    port: int = Field(description=\"DB connection port\")\n    password: str = Field(description=\"DB connection password\")\n\nif __name__ == \"__main__\":\n    config = load_config(CustomerDatabase)\n    print(config)\n</code></pre> <p>When <code>load_config(CustomerDatabase)</code> is executed, values are populated from environment variables or default values.</p>"},{"location":"essex-config/#nested-configurations","title":"Nested Configurations","text":"<p>Nest configuration objects:</p> <pre><code>class Inner(BaseModel):\n    inner_hello: str\n\nclass NestedConfiguration(BaseModel):\n    hello: str\n    nested: Inner\n\nnested_config = load_config(NestedConfiguration)\n</code></pre> <p><code>load_config()</code> populates every field, including <code>nested_config.nested.inner_hello</code>. The default prefix for every field in <code>Inner</code> is <code>nested</code>, which can be changed with <code>Annotated[Inner, Prefixed(\"new_prefix\")]</code>.</p>"},{"location":"essex-config/annotations/","title":"Field Annotations","text":"<p>Essex-config offers Annotations for fields which modifies the behavior of the basic configuration loading.</p>"},{"location":"essex-config/annotations/#prefixes","title":"Prefixes","text":"<p>The <code>load_config</code> function supports using a prefix for values in different sources:</p> <pre><code>class CustomerDatabase(BaseModel):\n    \"\"\"Configuration for connecting to the Customer Database\"\"\"\n    host: str = Field(default=\"127.0.0.1\", description=\"DB connection host\")\n    port: int = Field(description=\"DB connection port\")\n    password: str = Field(description=\"DB connection password\")\n\n\nif __name__ == \"__main__\":\n    config = load_config(CustomerDatabase, prefix=\"customer_db\")\n    print(config)\n\n</code></pre> <p>With a prefix, sources look for values accordingly:</p> <ul> <li><code>EnvSource()</code>: Uses UPPER_SNAKE_CASE (e.g., <code>CUSTOMER_DB_HOST</code>, <code>CUSTOMER_DB_PORT</code>, <code>CUSTOMER_DB_PASSWORD</code>).</li> <li><code>FileSource()</code>: Looks deeper into the file structure (e.g., <code>customer_db.host</code>).</li> <li><code>KeyvaultSource()</code>: Joins the prefix with the key using <code>.</code>.</li> </ul> <p>To add a prefix for a specific field, use <code>Annotated</code>:</p> <pre><code>class CustomerDatabase(BaseModel):\n    \"\"\"Configuration for connecting to the Customer Database\"\"\"\n    host: Annotated[str, Prefixed(\"some_prefix\")] = Field(default=\"127.0.0.1\", description=\"DB connection host\")\n    port: int = Field(description=\"DB connection port\")\n    password: str = Field(description=\"DB connection password\")\n</code></pre> <p>In this case, the prefix for <code>host</code> will be <code>customer_db.some_prefix</code>.</p>"},{"location":"essex-config/annotations/#alias","title":"Alias","text":"<p>Use <code>Annotated</code> to add source-specific aliases:</p> <pre><code>class CustomerDatabase(BaseModel):\n    \"\"\"Configuration for connecting to the Customer Database\"\"\"\n    host: Annotated[str, Alias(EnvSource, [\"customer_db_host\"])] = Field(default=\"127.0.0.1\", description=\"DB connection host\")\n    port: int = Field(description=\"DB connection port\")\n    password: str = Field(description=\"DB connection password\")\n</code></pre> <p><code>essex-config</code> will look to populate <code>host</code> from <code>customer_db_host</code> when using the <code>EnvSource</code>.</p>"},{"location":"essex-config/documentation/","title":"Documentation Generation","text":"<p>Generate documentation for configuration classes as a markdown file or print to the terminal:</p> <pre><code>python -m essex_config.doc_gen &lt;name-of-your-package&gt; &lt;ConfigurationClass1&gt; &lt;ConfigurationClass2&gt; ...\n</code></pre> <p>Add the --output option to specify a markdown file.</p> <p>Example of the markdown can be found in CONFIG_EXAMPLE.md</p>"},{"location":"essex-config/sources/","title":"Sources","text":"<p>Add different sources for configuration data using the <code>sources</code> parameter in the <code>load_config</code> call:</p> <p><code>essex-config</code> supports three built-in sources:</p> <ol> <li><code>EnvSource()</code>: Reads from environment variables. Looks for the field name in uppercase (e.g., <code>HOST</code> for <code>host</code>).</li> <li><code>FileSource(file_path: Path | str, use_env_var: bool = False)</code>: Reads from toml, json, or yaml files. <code>use_env_var=True</code> allows specifying the file path via an environment variable.</li> <li><code>KeyvaultSource(keyvault_name: str, use_env_var: bool = False)</code>: Fetches values from an Azure Key Vault. <code>use_env_var=True</code> allows specifying the Key Vault name via an environment variable.</li> </ol> <p>Example of multiple sources:</p> <pre><code>from pydantic import BaseModel, Field\nfrom essex_config import config\nfrom essex_config.sources import EnvSource, FileSource, KeyVaultSource\n\nclass CustomerDatabase(Config):\n    \"\"\"Configuration for connecting to the Customer Database\"\"\"\n    host: str = Field(default=\"127.0.0.1\", description=\"DB connection host\")\n    port: int = Field(description=\"DB connection port\")\n    password: str = Field(description=\"DB connection password\")\n\n\nif __name__ == \"__main__\":\n    config = load_config(CustomerDatabase, sources=[\n        EnvSource(),\n        FileSource(\"SETTINGS_PATH\", use_env_name=True),\n        KeyVaultSource(\"KEYVAULT_NAME\", use_env_name=True),\n        FileSource(\"pyproject.toml\")\n    ])\n    print(config)\n\n</code></pre> <p>Fields are populated from sources in the specified order.</p>"},{"location":"essex-config/sources/#custom-sources","title":"Custom Sources","text":"<p>Define custom sources by implementing a <code>Source</code> object and overriding the <code>_get_value()</code> and <code>__contains__()</code> methods. Optionally override the <code>_format()</code> method to provide a custom formatting for the prefix and key.</p> <p>Example of a custom source:</p> <pre><code>T = TypeVar(\"T\")\n\nclass MockSource(Source):\n    def __init__(self):\n        self.data = {\n            \"hello\": \"world\"\n        }\n\n    def _get_value(self, key: str, value_type: type[T]) -&gt; T:\n        return convert_to_type(self.data[key], value_type)\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Check if the key is present in the source.\"\"\"\n        return key in self.data\n</code></pre>"},{"location":"reactivedataflow/","title":"Getting Started","text":"<p>reactivedataflow is a Python library for building reactive data processing graphs. It is designed to work with streaming data sources.</p> <pre><code>pip install reactivedataflow\n</code></pre> <p>The dependencies for this project include <code>rx</code>, <code>networkx</code>, and <code>pydantic</code>.</p>"},{"location":"reactivedataflow/#legacy","title":"Legacy","text":"<p><code>reactivedataflow</code> has a design that is inspired by our prior work with datashaper and the neuron model of neural networks. In a neural network, individual neurons are connected to other neurons through synapses.  In traditional neural network topologies, there are \"hidden\" layers of normal neurons, in addition to special neurons that are designated as input neurons, and other neurons that are designated as output neurons.</p> <p>In <code>reactivedataflow</code>, we have a similar conceptual framework of Verb Nodes, Input Nodes, and Output Nodes.</p>"},{"location":"reactivedataflow/#nodes","title":"Nodes","text":"<p>Nodes are the heart of the system, and they are responsible for processing data streams and emitting transformed results. A key feature of this system is that data streams between nodes are polymorphic - meaning that they can be any type. Care should be taken that the processing function of a verb node is able to handle the data types that are passed to it.</p>"},{"location":"reactivedataflow/#input-nodes","title":"Input Nodes","text":"<pre><code>flowchart LR\n    A[rx source observable] --&gt; B((Input Node))\n    B --&gt; |default output| C[consumer]\n    B --&gt; |default output| D[consumer]\n    B --&gt; |default output| E[consumer]\n</code></pre> <p>Input nodes are simple nodes that are initialized with a <code>reactivex</code> event stream, and emit data on a single output port.</p>"},{"location":"reactivedataflow/#output-nodes","title":"Output Nodes","text":"<pre><code>flowchart LR\n    A((node)) --&gt; | named output | B((Output Node))\n    B --&gt;  C[graph reader]\n\n</code></pre> <p>Output nodes are simple nodes that are used to observe the output of a verb node. They are initialized with a reference to a verb node, and emit data on a single output port.  This is the primary mechanism for reading results from the processing graph.</p>"},{"location":"reactivedataflow/#verb-nodes","title":"Verb Nodes","text":"<pre><code>flowchart LR\n    A[named inputs] --&gt;|x| B((Verb Node))\n    A[named inputs] --&gt;|y| B((Verb Node))\n    A[named inputs] --&gt;|z| B((Verb Node))\n    C[array input] --&gt; |array input| B\n    D[configuration] --&gt; |named static values| B\n    B --&gt; |p| E[named outputs]\n    B --&gt; |q| E[named outputs]\n    B --&gt; |s| E[named outputs]\n</code></pre> <p>Verb nodes are composed of a number of \"ports\" that are used to describe their inputs, outputs, and configuration properties. </p> <ul> <li>Input ports represent data streams that are consumed by the verb node. Each message from an input port will result in a re-evaluation of the VerbNode's processing function, and may result in new messages being emitted on any number of output ports. </li> <li>The array input port is a special port type that allows for multiple input streams to be consumed by the verb node. This is useful for cases where multiple data streams are required to be processed together. When any of the input streams emit a message, the verb node will re-evaluate its processing function with the latest messages from all input streams.</li> <li>Configuration ports are used to provide static configuration values, such as system services or algorithmic hyper-parameters, to the verb node. These values are used to parameterize the processing function, and are not expected to change during the lifetime of the verb node.</li> <li>Output ports represent data streams that are emitted by the verb node. Each message emitted on an output port will be sent to any downstream nodes that are connected to the verb node via an input port.</li> </ul>"},{"location":"reactivedataflow/#edges","title":"Edges","text":"<p>Edges are used to connect nodes together in a processing graph. They are used to define the flow of data between nodes, and are used to establish the dependencies between nodes. Each edge represents an event-based reactive datastream. Edges are attached to two nodes. Edge properties may include:</p> <ul> <li>from node (required) - the source node id of the data stream.</li> <li>to node (required) - the destination node id of the data stream.</li> <li>to_port - the name of the input port in the target node. If this is not provided it will be treated as an array input.</li> <li>from_port - the name of the output port in the source node. If this is not provided it, we will use the default output name.</li> </ul>"},{"location":"reactivedataflow/examples/","title":"Examples","text":""},{"location":"reactivedataflow/examples/#simple-example","title":"Simple Example","text":"<p>The first task in using <code>reactivedataflow</code> is to define your relevant processing verbs. Processing verbs are pure functions that are annotated using the <code>@verb</code> decorator and the <code>Annotated</code> feature.  A key feature of <code>reactivedataflow</code> is that verb functions are not explicitly coupled to reactivedataflow, and may be used in other contexts as well.</p> <pre><code>from reactivedataflow import verb, Input, Config\nfrom typing import Annotated\n\n@verb(name=\"print\")\ndef print_verb(\n    val: Annotated[str, Input()], \n    prefix: Annotated[str, Config()] = \"\"\n) -&gt; str:\n    return f\"{prefix}{val}\"\n</code></pre> <p>Once we have a set of verbs defined, we can define a processing graph to establish a dataflow.  In this example, we'll load a simple one-node graph using the <code>Graph</code> schema.  The <code>GraphBuilder</code> also has a builder-mode API so that graphs can be defined iteratively.</p> <pre><code>import reactivex as rx\nfrom reactivedataflow import (\n    GraphBuilder,\n    Graph,\n    InputNode,\n    Node,\n    Edge,\n    Output\n)\n\n#\n# Define a simple graph\n#\ngraph = GraphBuilder().load_model(\n    Graph(\n        inputs=[InputNode(id=\"input\")],\n        nodes=[Node(id=\"printed\", verb=\"print\", config={\"prefix\": \"!\"})],\n        edges=[Edge(from_node=\"input\", to_node=\"printed\")],\n        outputs=[Output(name=\"result\", node=\"printed\")],\n    )\n).build(\n    inputs={\n        \"input\": rx.of([\"hello\", \"world\"]),\n    }\n)\ngraph.output(\"result\").subscribe(print)\n# Output: \n# !hello\n# !world\n</code></pre>"},{"location":"reactivedataflow/examples/#math-operators","title":"Math Operators","text":"<pre><code>\n@verb(\"add\")\ndef add(\n    values: Annotated[list[int], ArrayInput(min_inputs=1, defined_inputs=True)],\n) -&gt; int:\n    return sum(values)\n\n@verb(\"multiply\")\ndef multiply(a: Annotated[int, Input()], b: Annotated[int, Input()]) -&gt; int:\n    return a * b\n\n@verb(\"constant\")\ndef constant(value: Annotated[int, Config()]) -&gt; int:\n    return value\n\ngraph = GraphBuilder().load_model(\n    Graph(\n        inputs=[\n            InputNode(id=\"input\"),\n        ],\n        nodes=[\n            Node(id=\"c3\", verb=\"constant\", config={\"value\": 3}),\n            Node(id=\"c5\", verb=\"constant\", config={\"value\": ValRef(value=5)}),\n            Node(id=\"first_add\", verb=\"add\"),\n            Node(id=\"second_add\", verb=\"add\"),\n            Node(id=\"product\", verb=\"multiply\"),\n        ],\n        edges=[\n            # First sum inputs: 1 + 3 = 4\n            Edge(from_node=\"input\", to_node=\"first_add\"),\n            Edge(from_node=\"c3\", to_node=\"first_add\"),\n            # Second sum inputs: 5 + 3 = 8\n            Edge(from_node=\"c3\", to_node=\"second_add\"),\n            Edge(from_node=\"c5\", to_node=\"second_add\"),\n            # Multiply the sums: 4 * 8 = 32\n            Edge(from_node=\"first_add\", to_node=\"product\", to_port=\"a\"),\n            Edge(from_node=\"second_add\", to_node=\"product\", to_port=\"b\"),\n        ],\n        outputs=[Output(name=\"result\", node=\"product\")],\n    )\n).build(\n    inputs={\n        \"input\": rx.of([1]),\n    }\n)\ngraph.output(\"result\").subscribe(print)\n# Output: 32\n</code></pre>"},{"location":"reactivedataflow/examples/#math-operators-using-builder-api","title":"Math Operators using Builder API","text":"<pre><code># Assemble a graph:\n#\n#  n1 ----\\\n#         n3\n#  n2 ----/\n#\ngraph = GraphBuilder()\n    # Define Constant Layer\n    .add_node(\"c1\", \"constant\", config={\"value\": 1})\n    .add_node(\"c3\", \"constant\", config={\"value\": 3})\n    .add_node(\"c5\", \"constant\", config={\"value\": 5})\n    # Define Execution Layer\n    .add_node(\"n1\", \"add\")\n    .add_edge(from_node=\"c1\", to_node=\"n1\")\n    .add_edge(from_node=\"c3\", to_node=\"n1\")\n    .add_node(\"n2\", \"add\")\n    .add_edge(from_node=\"c3\", to_node=\"n2\")\n    .add_edge(from_node=\"c5\", to_node=\"n2\")\n    .add_node(\"n3\", \"multiply\")\n    .add_edge(from_node=\"n1\", to_node=\"n3\", to_port=\"a\")\n    .add_edge(from_node=\"n2\", to_node=\"n3\", to_port=\"b\")\n    .add_output(\"result\", \"n3\")\n    .build()\n</code></pre>"},{"location":"reactivedataflow/verbs/","title":"Verbs","text":"<p>Verbs are at the heart of <code>reactivedataflow</code>. Verbs are custom processing functions that react to input event streams and emit output event streams. Verbs are normally defined using pure functions which are annotated using the <code>@verb</code> decorator and the <code>Annotated</code> feature. This mechanism allows verbs to be used in other contexts as well, not just <code>reactivedataflow</code>, improving their utility and testability.</p> <p>At a base level, the system treats each verb as a function that accepts a <code>VerbInput</code> and returns a <code>VerbOutput</code>. The <code>verb</code> decorator and related annotations provide convenience mechanisms for adapting pure functions to fit into the execution model.</p>"},{"location":"reactivedataflow/verbs/#annotated-verbs-recommended","title":"Annotated Verbs (recommended)","text":"<pre><code>from reactivedataflow import verb, Input\nfrom typing import Annotated\n\n@verb(\"add\")\ndef add(\n    a: Annotated[int, Input()], \n    b: Annotated[int, Input()]\n) -&gt; int:\n    return a + b\n</code></pre> <p>Input Options:</p> <ul> <li><code>required</code> (bool, default=?): Whether this input is required. This is inferred from whether the argument has a default value.</li> </ul>"},{"location":"reactivedataflow/verbs/#raw-verbs","title":"Raw Verbs","text":"<pre><code>from reactivedataflow import verb, VerbInput, VerbOutput, InputMode, OutputMode\n\n@verb(\n    name=\"add\", \n    input_mode=InputMode.Raw, \n    output_mode=OutputMode.Raw\n)\ndef add(input: VerbInput) -&gt; VerbOutput:\n    return {\"result\": input[\"a\"] + input[\"b\"]}\n</code></pre>"},{"location":"reactivedataflow/verbs/#using-array-inputs","title":"Using Array Inputs","text":"<pre><code>from reactivedataflow import verb, ArrayInput\nfrom typing import Annotated\n\n@verb(\"add\")\ndef add(\n    inputs: Annotated[list[int], ArrayInput(min_inputs=2)]\n) -&gt; int:\n    return sum(inputs)\n</code></pre> <p>Array Input Options:</p> <ul> <li><code>required</code> (bool, default=?): Whether this input is required. This is inferred from whether the argument has a default value.</li> <li><code>min_inputs</code> (int, default=None): The minimum number of inputs that must be provided to the verb node.</li> <li><code>defined_inputs</code> (bool, default=False): If true, then each array value must be non-None for the verb to fire.</li> </ul>"},{"location":"reactivedataflow/verbs/#using-explicit-port-definitions","title":"Using Explicit Port Definitions","text":"<p>As an alternative to decorating function arguments, ports may be defined explicitly.  Each port has a name and maps into a parameter name.</p> <pre><code>from reactivedataflow import verb, Input, Config\n\n@verb(\n    \"add\",\n    ports=[\n        Input(name=\"input_1\", parameter=\"x\", required=True),\n        Input(name=\"input_2\", parameter=\"y\", required=True),\n        Config(name=\"config\", parameter=\"z\", required=False),\n        Output(name=\"output\"),\n    ]\n)\ndef add(x: int, y: int, z: int = 0) -&gt; int:\n    return x + y + z\n</code></pre>"},{"location":"reactivedataflow/verbs/#emitting-multiple-outputs","title":"Emitting Multiple Outputs","text":"<p>When multiple outputs are desired, you can set the <code>output_mode</code> to <code>OutputMode.Tuple</code> and provide a list of output port names.</p> <pre><code>@verb(\n    \"twin_outputs\",\n    output_names=[\"output_1\", \"output_2\"],\n    output_mode=OutputMode.Tuple,\n)\ndef twin_outputs(\n    x: Annotated[str | None, Input()], \n    y: Annotated[str | None, Input()]\n) -&gt; tuple[str, str]:\n    output_1 = f\"{x} {y}\"\n    output_2 = f\"{y} {x}\"\n    return output_1, output_2\n</code></pre>"},{"location":"reactivedataflow/verbs/#using-a-custom-registry","title":"Using a Custom Registry","text":"<p>There may be cases where you want to separate verb definitions from each other. This is most often used in testing. In these cases, verbs can be initialized with a custom registry instance. By default, a singleton registry is used.</p> <pre><code>from reactivedataflow import verb, Input, Config, VerbRegistry\n\nregistry = VerbRegistry()\n@verb(\"add\", registry=registry)\n...\n</code></pre>"},{"location":"reactivedataflow/verbs/#overriding-a-defined-verb","title":"Overriding a Defined Verb","text":"<p>Verbs are registered as their Python files are loaded. In situations where you need to override a verb definition, you can use the <code>override</code> parameter.</p> <pre><code>from reactivedataflow import verb, Input, Config, VerbRegistry\n\nregistry = VerbRegistry()\n@verb(\"add\", override=True)\n...\n</code></pre>"},{"location":"reactivedataflow/verbs/#adding-custom-adapters","title":"Adding Custom Adapters","text":"<p>You can register decorator functions that are applied before any <code>reactivedataflow</code> decoration is applied. This is useful for adding custom behavior to verbs.</p> <pre><code>from reactivedataflow import verb, Input, Config\n\ndef emit_telemetry(fn):\n    def wrap_fn():\n        print(f\"Calling {fn.__name__}\")\n        return fn()\n    return wrap_n\n\n@verb(\"add\", adapters=[emit_telemetry])\ndef add(\n    a: Annotated[int, Input()], \n    b: Annotated[int, Input()]\n) -&gt; int:\n    return a + b\n</code></pre>"},{"location":"reactivedataflow/verbs/#overriding-a-defined-verb_1","title":"Overriding a Defined Verb","text":"<p>Verbs are registered as their Python files are loaded. In situations where you need to override a verb definition, you can use the <code>override</code> parameter.</p> <pre><code>from reactivedataflow import verb, Input, Config, VerbRegistry\n\nregistry = VerbRegistry()\n@verb(\"add\", override=True)\n...\n</code></pre>"},{"location":"reactivedataflow/verbs/#fireemit-conditions","title":"Fire/Emit Conditions","text":"<p>The <code>verb</code> API allows for users to define firing and emitting conditions.  These are predicate functions that operate on <code>VerbInput</code> and <code>VerbOutput</code> objects. </p> <pre><code>from reactivedataflow import verb, Input, Config, VerbCondition, VerbInput\n\ndef fire_condition(input: VerbInput) -&gt; bool:\n    return input[\"a\"] &gt; 0\n\ndef emit_condition(input: VerbInput, output: VerbOutput) -&gt; bool:\n    return output[\"result\"] &gt; 0\n\n@verb(\n    \"add\", \n    fire_conditions=[fire_condition],\n    emit_conditions=[emit_condition]\n)\ndef add(\n    a: Annotated[int, Input()], \n    b: Annotated[int, Input()]\n) -&gt; int:\n    return a + b\n</code></pre>"}]}